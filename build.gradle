import com.liferay.gradle.util.OSDetector
import com.liferay.workspace.testing.ExecuteAndWaitForTask

import java.util.concurrent.TimeUnit;

import org.zeroturnaround.process.PidProcess
import org.zeroturnaround.process.ProcessUtil
import org.zeroturnaround.process.Processes

// Get executable file name based on OS
String executableFileName = OSDetector.isWindows() ? "catalina.bat" : "catalina.sh";

FileTree executableFilesFileTree = fileTree(gradle.liferayWorkspace.homeDir) {
	include("**/${executableFileName}")
}

/*
Currently, initBundle is very sensitive to any changes to the bundle directory's files,
meaning that it will re-run-too often and sometimes nuke the directory.

This bypasses that by only running if there are no startup scripts found.

The REAL fix is to update the initBundle task with more specific outputs declared.
*/
tasks.named("initBundle") {
	onlyIf {
		executableFilesFileTree.isEmpty()
	}
}

/*
Gather bundle info to configure the *TestableTomcat tasks and extension
 */
Provider<File> tomcatExecutableFileProvider = provider {
	executableFilesFileTree.singleFile
}

Provider<File> tomcatBinDirProvider = tomcatExecutableFileProvider.map {
	it.parentFile
}

Provider<File> tomcatDirProvider = tomcatBinDirProvider.map {
	it.parentFile
}

subprojects {
	Project project ->

	afterEvaluate {
		def buildClientExtensionZipTask = tasks.findByName("buildClientExtensionZip")

		if (buildClientExtensionZipTask != null) {
			clean {
				delete {
					String zipFileName = buildClientExtensionZipTask.archiveFileName.get()

					"${gradle.liferayWorkspace.homeDir}/osgi/client-extensions/${zipFileName}"
				}
			}
		}

		tasks.withType(ExecuteAndWaitForTask) {
			task ->
			String name = task.name

			String cleanTaskName = "clean" + name.charAt(0).toUpperCase() + name.substring(1)

			tasks.named(cleanTaskName) {
				doFirst {
					if (!task.pid.isPresent()) {
						return
					}

					PidProcess process = Processes.newPidProcess(task.pid.get());

					if (!process.isAlive()) {
						return
					}

					logger.lifecycle("Destroying background process with pid ${task.pid.get()}")

					ProcessUtil.destroyGracefullyOrForcefullyAndWait(process, 30, TimeUnit.SECONDS, 10, TimeUnit.SECONDS)
				}
			}
		}
	}

	pluginManager.withPlugin('com.liferay.test.integration') {
		dependencies {
			/*
			These dependencies are needed by the test runner
			 */
			testIntegrationImplementation group: "biz.aQute.bnd", name: "biz.aQute.bndlib", version: "3.5.0"
			testIntegrationImplementation group: "com.liferay", name: "org.apache.logging.log4j", version: "2.17.1.LIFERAY-PATCHED-1"
			testIntegrationImplementation group: "com.liferay", name: "org.apache.logging.log4j.core", version: "2.17.1.LIFERAY-PATCHED-1"
			testIntegrationImplementation group: "com.liferay.portal", name: "com.liferay.portal.test", version: "latest.release"
			testIntegrationImplementation group: "junit", name: "junit", version: "4.13.1"
			testIntegrationImplementation group: "org.slf4j", name: "log4j-over-slf4j", version: "1.7.25"
			testIntegrationImplementation group: 'com.liferay', name: 'com.liferay.arquillian.extension.junit.bridge', version: 'latest.release'

			/*
			These dependencies are deployed to the bundle
			 */
			testModules group: "com.liferay", name: "com.liferay.arquillian.extension.junit.bridge.connector", version: 'latest.release'
			testModules group: "com.liferay.portal", name: "com.liferay.portal.test", version: "latest.release"
			testModules group: "com.liferay.portal", name: "com.liferay.portal.test.integration", version: "latest.release"
			testModules group: "org.apache.aries.jmx", name: "org.apache.aries.jmx.core", version: "latest.release"
		}

		/*
		Configure the *TestableTomcat tasks and extension
		 */
		tasks.named('setUpTestableTomcat') {
			dir tomcatDirProvider
		}
		tasks.named('startTestableTomcat') {
			binDir tomcatBinDirProvider
		}
		tasks.named('stopTestableTomcat') {
			binDir tomcatBinDirProvider
		}
		testIntegrationTomcat {
			dir tomcatDirProvider
		}
	}
}

// Declare set up and tear down tasks for functional tests

tasks.register("setUpDependencies")
tasks.register("tearDownDependencies")

String functionalTestTaskName = "packageRunTestAllHeadless"

project(":playwright").afterEvaluate {
	Project project ->

	project.tasks.named("${functionalTestTaskName}") {
		mustRunAfter ":setUpDependencies"
	}
}

tasks.register("runFunctionalTests") {
	dependsOn ":setUpDependencies"
	dependsOn ":playwright:${functionalTestTaskName}"

	finalizedBy ":tearDownDependencies"
}

String setupProfile = findProperty("setupProfile") ?: "local"

apply from: "set-up-tests-${setupProfile}.gradle"
